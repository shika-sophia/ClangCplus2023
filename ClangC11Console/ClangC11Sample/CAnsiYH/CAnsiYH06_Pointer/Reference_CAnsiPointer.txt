/**
*@directory ClangC11Console / ClanC11Sample / CAnsiYH / CAnsiYH06_Pointer
*@fileName  Reference_CAnsiPointer.txt
*@reference C99YH    Œ‹é _ wCŒ¾ŒêƒvƒƒOƒ‰ƒ~ƒ“ƒOƒŒƒbƒXƒ“ [“ü–å•Ò] ‘æ‚R”ÅxSB Creative, 2019
*@reference CAnsiYH  Œ‹é _ wCŒ¾ŒêƒvƒƒOƒ‰ƒ~ƒ“ƒOƒŒƒbƒXƒ“ [•¶–@•Ò] V”Åx  SB Creative, 2006
*@reference C11DS    arton  w“ÆK C V”ÅxãÄ‰jĞ, 2018
*
*@content CAnsiYH Chapter 6  Pointer |  / List - / p107-
*@summary Reference_CAnsiPointer.txt
          ŸPointer Type kp49l<= copy from kCAnsiYH03_Type\Reference_CAnsiType.txtl

          ¡ Pointer kp107l
          ŸDefinition of Pointer kp108l
            –Pointer to Variable
            –Pointer to Function
          ŸAddress Operator [ & ]kp108l
          ŸIndirect-Reference and Assignment by Pointer kp109l
          ŸArithmetic caluclation of Pointer kp109l

*@English [E] correspond (v):     ‘Š“–‚·‚éAˆê’v‚·‚éA‘Î‰‚·‚é
                correspond to:    ˆê’v‚·‚é
                correspond with:  ‘ŠŒİì—p‚ª‚ ‚é
          [E] derive     (v):     ”h¶‚·‚éA“±‚­A—R—ˆ‚·‚é
          [E] indirect (adj):     ŠÔÚ“I  <->  direct ’¼Ú“I
          [E] refer      (v):     QÆ‚·‚éA’l‚ğ“¾‚é    reference (n) | referred (v/adj)
          [E] assign     (v):     Š„‚è“–‚Ä‚éA‘ã“ü‚·‚é  assignment (n)
          [E] indicate   (v):     w‚µ¦‚·
          [E] storage  (n/v):     Ši”[‚·‚éA‹L‰¯‚·‚éA’™‘ ‚·‚é
          [E] strict   (adj):     Œµ–§, Œµ‚µ‚­, ŒÅ‚­, ŒµŠi, Œµd, ‚ ‚­‚Ü‚Å
          [E] confuse    (v):     ¬“¯‚·‚é
          [E] identify   (v):     “¯ˆê‹‚·‚é
          [E] omit       (n/v):   ”²‚©‚·AÈ‚­
          [E] abbreviate (v):     È—ª‚·‚éA’Zk‚·‚é  abbreviation (n) È—ªŒ`
          [E] specification (n):  w’èAd—lA‹KŠi

          [P] define     (v):     ’è‹`‚·‚é   | defintion   (n) ’è‹`
          [P] declarate  (v):     éŒ¾‚·‚é   | declaration (n) éŒ¾  [P] ƒvƒƒgƒ^ƒCƒvéŒ¾
          [P] operator   (n):     ‰‰Zq
          [P] qualifier  (n):     Cüq
          [P] identifier (n):     ¯•ÊqA–¼‘O
          [P] initializer(n):     ‰Šú‰»q { }

          [M] Arithmetic (n/adj): Zp, ‰‰Z, Z”, Zp‰‰Z, Z”‰È

*@see     CAnsiYH03_Type\Reference_CAnsiType.txt
*@see     C99YH11_Pointer\MainPointerBasic.c
*@author  shika
*@date    2023-02-07
*/ 

*@subject ŸPointer Type kp49l<= copy from kCAnsiYH03_Type\Reference_CAnsiType.txtl
          [Definition]
          EPointer: The Type which indicate address of some Type value or the value.
          Eaddress: The location in Memory, expressed by 'int' value.
           (In Assembler, it corresponds to "Indirect-Reference".)

          [Operator of Pointer]
          EAddress Operator  [ & ]:  It means the adderss of Variable, expressed such as '&x'.
          EIndirect Operator [ * ]:  It means Indirect-Refernence value of Variable which Pointer indicate, 
                                      expressed such as '*p'.
          EAssign Operator [ = ]:    When Pointer is assigned Address of some Variable, it is expressed such as 'p = &x;'
          EArithmetic Operator [ + - ++ -- ]: 
               To add or subtract value of Pointer, mean to navigate address of Variable value which Pointer indicate.
               so that we can regard Memory as Array of Object (= Variable) by using Pointer.
               Actually, These are the same meaning, incresing value of Pointer and specifing index of Pointer Array
               expressed such as *(p + m) and p[m] (assuming p: Pointer, m: int value).

               => more detialkRelation of Array and Pointer | CAnsiYH p111l

          ECompare Operator [ == < > ... ]: Pointer can be compared by using them.

          => copy from kCAnsiYH03_Type\Reference_CAnsiType.txtl

*@subject ¡ Pointer kp107l
          Pointer: EA Type which indicate address of a Variable, Function, or Object such as Array.
                   EPointer is one of Derived Types which can be self-defined by Programmer. 
                     => Derived Types kCAnsiYH03_Type\Reference_CAnsiType.txtl
                   EAssuming that there is a Type 'T', the Pointer to T is expressed as Type 'T*',
                     which is called "Pointer to T Type" or "Pointer which indicate T Type".
                   EWe can indirectly refer and assign to some Variables by using a Pointer. => Indirect-Referencekbelowl

          Indirect-Reference: 
                   When a Pointer indicate a Variable 'int i',
                   we can refer to the value of 'i' and assign some value to 'i', by using the Pointer.
                   => [Example] in "ŸIndirect-Reference and Assignment by Pointer". kmore belowl

          Pointer Variable: Variable of Type T*
          Pointer value:    value of Type T*
          It is often complicated that "Pointer Variable" or "Pointer value" are simply called "Pointer".

          [Example]
          int i;    // Definition Variable of 'int' Type
          int *ip;  // Definition Pointer which indicate address of 'int' Type.

          ip = &i;  // Pointer 'ip' is assigned address of Variable 'int i', expressed by Adderss Operator [ & ].
                    // Then the Pointer storage address in Memory of it.
                    // In the other words, Conditional Expression 'ip == &i' is true.
                    // When a Pointer 'ip' indicate a Variable 'int i',
                    // we can refer to the value of 'i' and assign some value to 'i', by using the Pointer 'ip'.

          int *ip = &i; // We can write that, as Definition and Intialization Pointer at the same time.
                        // Though Indirect Operator [ * ] express the value of Variable which Pointer indicate,
                        // the expression 'int *ip = &i;' means both of Definition Pointer 'int *ip;' and Intialization 'ip = &i;'. 

*@subject ŸDefinition of Pointer kp108l
          [Example]
          –Pointer to Variable
          int  *ip;                 // Definition Pointer 'ip' which indicate 'int' Type.
          char *cp;                 // Definition Pointer 'cp' which indicate 'char' Type.
          struct SchoolMate *mateP; // Definition Pointer 'mateP' which indicate 'struct SchoolMate'.
          T    *tp                  // Generally, Definition Pointer 'tp' which indicate 'T' Type.

          –Pointer to Function
          int (*fp)(char);          // Definition Pointer 'fp' which indicate Function whose Argument is one 'char' Type and whose Return-Type is 'int' Type.

*@subject ŸAddress Operator [ & ]kp108l
          Address Operator [ & ]: 
            EOperator which add '&' before Variable to express address of the Variable.
              Strictly, the Variable which can be put as 'Left Side Value'.
              => Left Side Value kCAnsiYH p74lkCAnsiYH04_Variable\Reference_CAnsiVariable.txtl
            
            EPointer is intialized or assigned address of Variable with '&', as [Examble] above.
              
            EThough the symbol '&' is as same as Bit Arithemetic Operator [ & ] or Logical Operator [ && ],
              of course, it is different meaning from these.

*@subject ŸIndirect-Reference and Assignment by Pointer kp109l
          Indirect-Reference: kabovel

          [Example] 
          int i;
          int *ip = &i;

          *ip = 10;     // The assignment change value of Variable 'i' to 10 and Pointer value '*ip' to 10,
                        // but Pointer 'ip' is no change, still.
                        // Therefore, Don't confuse or identify Pointer value '*ip' and Pointer Variable 'ip',
                        // which are different.

*@subject ŸArithmetic caluclation of Pointer kp109, p154l
          EAdd, Subtract Integer value: Add or Subtract of Pointer Variable move address which Pointer indicate, to later or former.
          EConsequently, To Add +m' or to subtract '-n' move address to (p + m) or (p - n).
          EBy that, Programmer can move address, while one need not consider about Memory size of Object, expressed by 'sizeof(Object)'.
          
          [Example]
          long a[10];
          long *p = &a[3];

          When Array 'a[]' and Pointer 'p' is defined, expression (p + 1) means '&a[4]',
          so that expression *(p + 1) means value of 'a[4]'.
          Therefore, Addition +1 of Pointer Variable move address which Pointer indicate, to next array index,
          Subtraction -1 of Pointer Variable move address which Pointer indicate, to previous array index.
          Consequently, To Add +m' or to subtract '-n' move address to (p + m) or (p - n).

@subject ŸCompare Pointers as same Type both kp109, p154l
         Difference of Pointers as same Type both:
           Assuming Poiter 'p' and Pointer 'q' as same Type both, 
           Expression 'p - q' means the numbers of Pointer between 'p' and 'q',
           so that the value can be plus, minus, or 0.

         Pointers as same Type both can be compared such as that:
           if Subtract 'p - q' is plus value,  'p > q'  is true.
           if Subtract 'p - q' is minus value, 'p > q'  is false.
           if Subtract 'p - q' is 0 value,     'p == q' is true.

         –<stddef.h> -- ptrdiff_t Type
         ptrdiff_t: Type which express Difference of Pointers as same Type both, as subtract,
                    default-defined in <stddef.h>. =>kCAnsiYH Chapter 12 | p288l

*@subject ŸNULL Pointer kp109lkC99YH p364lkC99YH11_Pointer\MainPointerBasic.cl
          <stdio.h> => INDEXkC99YH12_FileOperation/MainFileOpenInputSample.cl
             „¤ #define NULL 0

          NULL Pointer: 
           EThe constant value which indicate nowhere. It means no reference.
           EThe constant value is often defined as '0', depending on Compiler,
             so that Conditional Expression 'if(NULL)' is false.

             [Example]
             FILE *fp = fopen(...);
             if(!fp) { ... }         // as same as 'if(fp == NULL)'
             if(fp)  { ... }         // as same as 'if(fp != NULL)'

           EWe cannot refer and assign to address of NULL Pointer.
             If we would do, we will be thrown Runtime Error,
             because Compiler cannot find address which NULL Pointer indicate,
             as like NullPointerException in [Java][C#].

           EWe can assign NULL to any Pointer, that means no reference or to delete the already reference.
           EWe can assign 0    to any Pointer, that means to assgin NULL.
           ENULL Check: Before we operate 'p', it is necessary to check if p is NULL or not.
 
            [Example]
            int *p;
            p = NULL;
  
            [~] *p = 123;  -> Runtime Error: NULL pointer assignment,
                           -> or output unexpected value, or do unexpeted behavior,
                           -> or enforcely exited by OS.
  
            [~] printf("%p \n", p);  // when 'p = NULL'
  
            [Example] NULL Check
            if (p != NULL) {
                // write operation: assginment or reference, about 'p' here.
            }
  

           EThe reason why NULL Pointer is necessary:
             Because Compiler can tell Error of Function to Programmer, as NULL Pointer,
             when we use Function whose Return-Type is Pointer Type, such as that:
               Function 'FILE* fopen( ... )' which open a file of argument, whose Return-Type is FILE Pointer 'FILE*',
               if 'fopen()' cannot open the file, it return NULL Pointer. 
               Function 'void* malloc()' which take a space in Memory, whose Return-Value is Generic Pointer 'void*',
               if 'malloc()' cannot take a space in Memory, it return NULL Pointer.
            Because NULL Pointer is used to express end of link,
            when we use Liner List or Tree Data Structure.

           EDon't confuse and identify NULL Pointer, Empty-String "" and NULL Character '\0',
             these are different things.

           => copy to/fromkC99YH12_FileOperation/MainFileOpenInputSample.cl

*@subject ŸInvalid Pointer kp110l
          Invalid Pointer: 
            EIt is not "NULL Pointer", but Pointer which indicate Invalid Object, such as below.
            EThere is a case of Runtime Errorõ, if we refer to Invalid Object by Pointer.
            
          Invalid Object
            Edifferent Type Literal ??
            EArray whose index is out of range.
            E'auto' Variable which has not been initialized yet.
            EThe 'p' value, when we disposed Object once by using Function 'free(p)'.

          [Example]
          char *cp = (char*) 123;  // different Type Literal ??
          int  *iP = &a[-1];       // The Pointer which indicate address of Array whose index is out of range

          õyAnnotationz"There is a case of Runtime Error":
          EThere is a case that Compiler cannot find the indirect-reference of "Invalid" Pointer, depending on environment of PC.
          EThere is a case that "Invalid" Pointer accidentally indicate the other address of value entirely without relationship, too.
          In these cases, Runtime Error is not thrown, that is unexpected behavior.

*@subject ŸArray and Pointerkp96, p111, p113l
 
          see kCAnsiYH05_Array\Reference_CAnsiArray.txtl
          Array and Pointer kCAnsiYH p96l
            –Difference of Memory structure about Array and Pointer
            –Sort by Array and Pointer kCAnsiYH p98l

          Array and Pointer are closely related such as that:
          EArray name is recognized as Pointer value which indicate first element of the Array, such as that:
            
            [Example]
            int a[10];
            int *P = a;   // <=>  int *p = &a[0];

            Array name 'a' and address of Array first element '&a[0]' are the same value,
            so that Conditional Expression 'if(a == &a[0])' is true,
            so that Expression 'a[i]' is equal to '*(a + i)'.

           yAnnotationzOperator 'sizeof()'
            There is a exception of the specification 'if(a == &a[0])' above.
            When we use Operator 'sizeof()',
            Memory size of Array name 'sizeof(a)' which means size of whole Array, and
            Memory size of address 'sizeof(&a[0])' which means size of Array first element, are usually different value.
           
          –Array of Function Argument kp113l
          EWe cannot give whole of Array to Argument of Function,            
            so that we can only give Pointer which indicate address of Array first element to Argument.

            [Example] Calling Function
            char buffer[BUFFER_SIZE];
            gets(buffer);  
            
            The Calling Function 'gets(buffer);' is given not whole of Array 'buffer[]' as Argument,
            but address '&buffer[0]' of Array first element only,
            remembering Array name 'a' means address '&a[0]' of Array first element, as above.

          EArray of Function Argument actually means Pointer to the Array, such as that:
            [Example] Declaration
            int count(char a[]);
                         ||  the same meaning
            int count(char *a);

          yAnnotationz"Value-Giving" of Function Argument
           If we could give whole of Array to Argument,
           nevertheless, because Functions in C language is done "Value-Giving", 
           some operations in the Function cannot effect any influences to the Array local-defined in origin of Calling Function.
           
           => "Value-Giving" and "Refernce-Giving" kCAnsiYH Chapter 10 Function | p220l

*@subject ŸString text and Pointer kp112l
          constant value of String text "Hello" is equal to 'char' Array such as that:
            char a[] = { 'H', 'e', 'l', 'l', 'o', '.', '\0' };

          So that 'char' Pointer can be initialized by String text "Hello", such as that:
            char *cp = "Hello.";

          In this case, the value '*cp' which Pointer indicate, is 'H',
          so that Conditional Expression 'if(*cp == 'H')' is true.

*@subject ŸStruct and Pointer kp112l
          –Reference of Pointer 'mateP' which indicate 'struct SchoolMate'
          –Reference of Union is as same.

          [Example] Declaration
          sturct SchoolMate {
              int id;
              char name[10];
          }

          struct Schoolmate *mateP;

          [Example] Reference
          (*mateP).id  // The expression means to refer to the member of Struct which Pointer indicate.
                       // The Priority-bracket '()' cannot be omited, because of Operator priority.
                       // If it were omited such as '*mateP.id', the expression means '*(mateP.id)' as different meaning.
          
          mateP -> id  // Operator '->' is an abbreviation of above, 
                       // which is one Operator of two characters '-' and '>',
                       // so that two characters cannot be inserted white-space between both.

          mateP->xp->value  // When member of Struct which Pointer 'mateP' indicate, is another Pointer 'xp',
                            // the Operators '->' can be used combinedly.

*@subject ŸFunction and Pointer kp113l
          => ŸArray and Pointer 
             –Array of Function Argumentkabovel

*@subject –Struct of Function Argument kp114l
          

[EOF]