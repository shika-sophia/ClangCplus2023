/**
*@directory ClangC11Console / ClanC11Sample / CAnsiYH / CAnsiYH06_Pointer
*@fileName  Reference_CAnsiPointer.txt
*@reference C99YH    Œ‹é _ wCŒ¾ŒêƒvƒƒOƒ‰ƒ~ƒ“ƒOƒŒƒbƒXƒ“ [“ü–å•Ò] ‘æ‚R”ÅxSB Creative, 2019
*@reference CAnsiYH  Œ‹é _ wCŒ¾ŒêƒvƒƒOƒ‰ƒ~ƒ“ƒOƒŒƒbƒXƒ“ [•¶–@•Ò] V”Åx  SB Creative, 2006
*@reference C11DS    arton  w“ÆK C V”ÅxãÄ‰jĞ, 2018
*
*@content CAnsiYH Chapter 6  Pointer |  / List - / p107-
*@summary Reference_CAnsiPointer.txt
          ŸPointer Type kp49l<= copy from kCAnsiYH03_Type\Reference_CAnsiType.txtl

          ¡ Pointer kp107l
          ŸDefinition of Pointer kp108l
            –Pointer to Variable
            –Pointer to Function
          ŸAddress Operator [ & ]kp108l
          ŸIndirect-Reference and Assignment by Pointer kp109l
          ŸArithmetic caluclation of Pointer kp109l
          ŸCompare Pointers as same Type both kp109, p154l
          ŸNULL Pointer kp109lkC99YH p364lkC99YH11_Pointer\MainPointerBasic.cl
          <stdio.h> => INDEXkC99YH12_FileOperation/MainFileOpenInputSample.cl
             „¤ #define NULL 0
          ŸNULL Pointer as end of String text kp118l
          ŸInvalid Pointer kp110l
          ŸArray and Pointerkp96, p111, p113l
          ŸString text and Pointer kp112l
          ŸStruct and Pointer kp112l
          ŸFunction and Pointer kp113l
            –Array of Function Argument
            –Struct of Function Argument kp114l
          Ÿmulti Return-Value of Function by using Pointer kp114l
          ŸPointer of Function kp115l
          Command Table by using Pointer of Function kp116l
          Handler kp116, p282l
          ŸPointer of Pointer kp117l kC99YH11_Pointer\MainPointerOfPointerSample.cl
          Ÿ<stdlib.h> -- strtol()  kp117, p329l
          ŸGeneric Pointer 'void*' kp118l

*@English [E] correspond (v):     ‘Š“–‚·‚éAˆê’v‚·‚éA‘Î‰‚·‚é
                correspond to:    ˆê’v‚·‚é
                correspond with:  ‘ŠŒİì—p‚ª‚ ‚é
          [E] derive     (v):     ”h¶‚·‚éA“±‚­A—R—ˆ‚·‚é
          [E] indirect (adj):     ŠÔÚ“I  <->  direct ’¼Ú“I
          [E] refer      (v):     QÆ‚·‚éA’l‚ğ“¾‚é    reference (n) | referred (v/adj)
          [E] assign     (v):     Š„‚è“–‚Ä‚éA‘ã“ü‚·‚é  assignment (n)
          [E] indicate   (v):     w‚µ¦‚·
          [E] storage  (n/v):     Ši”[‚·‚éA‹L‰¯‚·‚éA’™‘ ‚·‚é
          [E] strict   (adj):     Œµ–§, Œµ‚µ‚­, ŒÅ‚­, ŒµŠi, Œµd, ‚ ‚­‚Ü‚Å
          [E] confuse    (v):     ¬“¯‚·‚é
          [E] identify   (v):     “¯ˆê‹‚·‚é
          [E] omit       (n/v):   ”²‚©‚·AÈ‚­
          [E] abbreviate (v):     È—ª‚·‚éA’Zk‚·‚é  abbreviation (n) È—ªŒ`
          [E] specification (n):  w’èAd—lA‹KŠi
          [E] generic  (adj):     ”Ä—p (= ˆê”Ê‚É’Ê—p‚·‚é)  =:=  general (adj): ˆê”Ê“I‚È

          [P] define     (v):     ’è‹`‚·‚é   | defintion   (n) ’è‹`
          [P] declarate  (v):     éŒ¾‚·‚é   | declaration (n) éŒ¾  [P] ƒvƒƒgƒ^ƒCƒvéŒ¾
          [P] operator   (n):     ‰‰Zq
          [P] qualifier  (n):     Cüq
          [P] identifier (n):     ¯•ÊqA–¼‘O
          [P] initializer(n):     ‰Šú‰»q { }

          [M] Arithmetic (n/adj): Zp, ‰‰Z, Z”, Zp‰‰Z, Z”‰È
          [M] recursive (adj):    Ä‹A“I (= ©•ª©g‚Æ“¯‚¶\‘¢‚Ì‚à‚Ì‚ğŒJ‚è•Ô‚·‚±‚Æ) | recursion (n), recurse (v)

*@see     CAnsiYH03_Type\Reference_CAnsiType.txt
*@see     C99YH11_Pointer\MainPointerBasic.c
*@author  shika
*@date    2023-02-07
*/ 

*@subject ŸPointer Type kp49l<= copy from kCAnsiYH03_Type\Reference_CAnsiType.txtl
          [Definition]
          EPointer: The Type which indicate address of some Type value or the value.
          Eaddress: The location in Memory, expressed by 'int' value.
           (In Assembler, it corresponds to "Indirect-Reference".)

          [Operator of Pointer]
          EAddress Operator  [ & ]:  It means the adderss of Variable, expressed such as '&x'.
          EIndirect Operator [ * ]:  It means Indirect-Refernence value of Variable which Pointer indicate, 
                                      expressed such as '*p'.
          EAssign Operator [ = ]:    When Pointer is assigned Address of some Variable, it is expressed such as 'p = &x;'
          EArithmetic Operator [ + - ++ -- ]: 
               To add or subtract value of Pointer, mean to navigate address of Variable value which Pointer indicate.
               so that we can regard Memory as Array of Object (= Variable) by using Pointer.
               Actually, These are the same meaning, incresing value of Pointer and specifing index of Pointer Array
               expressed such as *(p + m) and p[m] (assuming p: Pointer, m: int value).

               => more detialkRelation of Array and Pointer | CAnsiYH p111l

          ECompare Operator [ == < > ... ]: Pointer can be compared by using them.

          => copy from kCAnsiYH03_Type\Reference_CAnsiType.txtl

*@subject ¡ Pointer kp107l
          Pointer: EA Type which indicate address of a Variable, Function, or Object such as Array.
                   EPointer is one of Derived Types which can be self-defined by Programmer. 
                     => Derived Types kCAnsiYH03_Type\Reference_CAnsiType.txtl
                   EAssuming that there is a Type 'T', the Pointer to T is expressed as Type 'T*',
                     which is called "Pointer to T Type" or "Pointer which indicate T Type".
                   EWe can indirectly refer and assign to some Variables by using a Pointer. => Indirect-Referencekbelowl

          Indirect-Reference: 
                   When a Pointer indicate a Variable 'int i',
                   we can refer to the value of 'i' and assign some value to 'i', by using the Pointer.
                   => [Example] in "ŸIndirect-Reference and Assignment by Pointer". kmore belowl

          Pointer Variable: Variable of Type T*
          Pointer value:    value of Type T*
          It is often complicated that "Pointer Variable" or "Pointer value" are simply called "Pointer".

          [Example]
          int i;    // Definition Variable of 'int' Type
          int *ip;  // Definition Pointer which indicate address of 'int' Type.

          ip = &i;  // Pointer 'ip' is assigned address of Variable 'int i', expressed by Adderss Operator [ & ].
                    // Then the Pointer storage address in Memory of it.
                    // In the other words, Conditional Expression 'ip == &i' is true.
                    // When a Pointer 'ip' indicate a Variable 'int i',
                    // we can refer to the value of 'i' and assign some value to 'i', by using the Pointer 'ip'.

          int *ip = &i; // We can write that, as Definition and Intialization Pointer at the same time.
                        // Though Indirect Operator [ * ] express the value of Variable which Pointer indicate,
                        // the expression 'int *ip = &i;' means both of Definition Pointer 'int *ip;' and Intialization 'ip = &i;'. 

*@subject ŸDefinition of Pointer kp108l
          [Example]
          –Pointer to Variable
          int  *ip;                 // Definition Pointer 'ip' which indicate 'int' Type.
          char *cp;                 // Definition Pointer 'cp' which indicate 'char' Type.
          struct SchoolMate *mateP; // Definition Pointer 'mateP' which indicate 'struct SchoolMate'.
          T    *tp                  // Generally, Definition Pointer 'tp' which indicate 'T' Type.

          –Pointer to Function   kp115, belowl
          int (*fp)(char);         // Definition Pointer 'fp' which indicate Function whose Argument is one 'char' Type and whose Return-Type is 'int' Type.

*@subject ŸAddress Operator [ & ]kp108l
          Address Operator [ & ]: 
            EOperator which add '&' before Variable to express address of the Variable.
              Strictly, the Variable which can be put as 'Left Side Value'.
              => Left Side Value kCAnsiYH p74lkCAnsiYH04_Variable\Reference_CAnsiVariable.txtl
            
            EPointer is intialized or assigned address of Variable with '&', as [Examble] above.
              
            EThough the symbol '&' is as same as Bit Arithemetic Operator [ & ] or Logical Operator [ && ],
              of course, it is different meaning from these.

*@subject ŸIndirect-Reference and Assignment by Pointer kp109l
          Indirect-Reference: kabovel

          [Example] 
          int i;
          int *ip = &i;

          *ip = 10;     // The assignment change value of Variable 'i' to 10 and Pointer value '*ip' to 10,
                        // but Pointer 'ip' is no change, still.
                        // Therefore, Don't confuse or identify Pointer value '*ip' and Pointer Variable 'ip',
                        // which are different.

*@subject ŸArithmetic caluclation of Pointer kp109, p154l
          EAdd, Subtract Integer value: Add or Subtract of Pointer Variable move address which Pointer indicate, to later or former.
          EConsequently, To Add +m' or to subtract '-n' move address to (p + m) or (p - n).
          EBy that, Programmer can move address, while one need not consider about Memory size of Object, expressed by 'sizeof(Object)'.
          
          [Example]
          long a[10];
          long *p = &a[3];

          When Array 'a[]' and Pointer 'p' is defined, expression (p + 1) means '&a[4]',
          so that expression *(p + 1) means value of 'a[4]'.
          Therefore, Addition +1 of Pointer Variable move address which Pointer indicate, to next array index,
          Subtraction -1 of Pointer Variable move address which Pointer indicate, to previous array index.
          Consequently, To Add +m' or to subtract '-n' move address to (p + m) or (p - n).

@subject ŸCompare Pointers as same Type both kp109, p154l
         Difference of Pointers as same Type both:
           Assuming Poiter 'p' and Pointer 'q' as same Type both, 
           Expression 'p - q' means the numbers of Pointer between 'p' and 'q',
           so that the value can be plus, minus, or 0.

         Pointers as same Type both can be compared such as that:
           if Subtract 'p - q' is plus value,  'p > q'  is true.
           if Subtract 'p - q' is minus value, 'p > q'  is false.
           if Subtract 'p - q' is 0 value,     'p == q' is true.

         –<stddef.h> -- ptrdiff_t Type
         ptrdiff_t: Type which express Difference of Pointers as same Type both, as subtract,
                    default-defined in <stddef.h>. =>kCAnsiYH Chapter 12 | p288l

*@subject ŸNULL Pointer kp109lkC99YH p364lkC99YH11_Pointer\MainPointerBasic.cl
          <stdio.h> => INDEXkC99YH12_FileOperation/MainFileOpenInputSample.cl
             „¤ #define NULL 0

          NULL Pointer: 
           EThe constant value which indicate nowhere. It means no reference.
           EThe constant value is often defined as '0', depending on Compiler,
             so that Conditional Expression 'if(NULL)' is false.

             [Example]
             FILE *fp = fopen(...);
             if(!fp) { ... }         // as same as 'if(fp == NULL)'
             if(fp)  { ... }         // as same as 'if(fp != NULL)'

           EWe cannot refer and assign to address of NULL Pointer.
             If we would do, we will be thrown Runtime Error,
             because Compiler cannot find address which NULL Pointer indicate,
             as like NullPointerException in [Java][C#].

           EWe can assign NULL to any Pointer, that means no reference or to delete the already reference.
           EWe can assign 0    to any Pointer, that means to assgin NULL.
           ENULL Check: Before we operate 'p', it is necessary to check if p is NULL or not.
 
            [Example]
            int *p;
            p = NULL;
  
            [~] *p = 123;  -> Runtime Error: NULL pointer assignment,
                           -> or output unexpected value, or do unexpeted behavior,
                           -> or enforcely exited by OS.
  
            [~] printf("%p \n", p);  // when 'p = NULL'
  
            [Example] NULL Check
            if (p != NULL) {
                // write operation: assginment or reference, about 'p' here.
            }
  

           EThe reason why NULL Pointer is necessary:
             Because Compiler can tell Error of Function to Programmer, as NULL Pointer,
             when we use Function whose Return-Type is Pointer Type, such as that:
               Function 'FILE* fopen( ... )' which open a file of argument, whose Return-Type is FILE Pointer 'FILE*',
               if 'fopen()' cannot open the file, it return NULL Pointer. 
               Function 'void* malloc()' which take a space in Memory, whose Return-Value is Generic Pointer 'void*',
               if 'malloc()' cannot take a space in Memory, it return NULL Pointer.
            Because NULL Pointer is used to express end of link,
            when we use Liner List or Tree Data Structure.

           EDon't confuse and identify NULL Pointer, Empty-String "" and NULL Character '\0',
             these are different things.

           => copy to/fromkC99YH12_FileOperation/MainFileOpenInputSample.cl

*@subject ŸNULL Pointer as end of String text kp118l
          [Example]
          char *usage[] = {
              "Usage:",
              "    cmd file1 file2",
              "Description:",
              "    The Program compare two files, file1 and file2.",
              "    and then ... ",
              "    ... ",
              NULL,
          };

*@subject ŸInvalid Pointer kp110l
          Invalid Pointer: 
            EIt is not "NULL Pointer", but Pointer which indicate Invalid Object, such as below.
            EThere is a case of Runtime Errorõ, if we refer to Invalid Object by Pointer.
            
          Invalid Object
            Edifferent Type Literal ??
            EArray whose index is out of range.
            E'auto' Variable which has not been initialized yet.
            EThe 'p' value, when we disposed Object once by using Function 'free(p)'.

          [Example]
          char *cp = (char*) 123;  // different Type Literal ??
          int  *iP = &a[-1];       // The Pointer which indicate address of Array whose index is out of range

          õyAnnotationz"There is a case of Runtime Error":
          EThere is a case that Compiler cannot find the indirect-reference of "Invalid" Pointer, depending on environment of PC.
          EThere is a case that "Invalid" Pointer accidentally indicate the other address of value entirely without relationship, too.
          In these cases, Runtime Error is not thrown, that is unexpected behavior.

*@subject ŸArray and Pointerkp96, p111, p113l
 
          see kCAnsiYH05_Array\Reference_CAnsiArray.txtl
          Array and Pointer kCAnsiYH p96l
            –Difference of Memory structure about Array and Pointer
            –Sort by Array and Pointer kCAnsiYH p98l

          Array and Pointer are closely related such as that:
          EArray name is recognized as Pointer value which indicate first element of the Array, such as that:
            
            [Example]
            int a[10];
            int *P = a;   // <=>  int *p = &a[0];

            Array name 'a' and address of Array first element '&a[0]' are the same value,
            so that Conditional Expression 'if(a == &a[0])' is true,
            so that Expression 'a[i]' is equal to '*(a + i)'.

           yAnnotationzOperator 'sizeof()'
            There is a exception of the specification 'if(a == &a[0])' above.
            When we use Operator 'sizeof()',
            Memory size of Array name 'sizeof(a)' which means size of whole Array, and
            Memory size of address 'sizeof(&a[0])' which means size of Array first element, are usually different value.
           
          –Array of Function Argument kp113l
          EWe cannot give whole of Array to Argument of Function,            
            so that we can only give Pointer which indicate address of Array first element to Argument.

            [Example] Calling Function
            char buffer[BUFFER_SIZE];
            gets(buffer);  
            
            The Calling Function 'gets(buffer);' is given not whole of Array 'buffer[]' as Argument,
            but address '&buffer[0]' of Array first element only,
            remembering Array name 'a' means address '&a[0]' of Array first element, as above.

          EArray of Function Argument actually means Pointer to the Array, such as that:
            [Example] Declaration
            int count(char a[]);
                         ||  the same meaning
            int count(char *a);

          yAnnotationz"Value-Giving" of Function Argument
           If we could give whole of Array to Argument,
           nevertheless, because Functions in C language is done "Value-Giving", 
           some operations in the Function cannot effect any influences to the Array local-defined in origin of Calling Function.
           
           => "Value-Giving" and "Refernce-Giving" kCAnsiYH Chapter 10 Function | p220l

*@subject ŸString text and Pointer kp112l
          constant value of String text "Hello" is equal to 'char' Array such as that:
            char a[] = { 'H', 'e', 'l', 'l', 'o', '.', '\0' };

          So that 'char' Pointer can be initialized by String text "Hello", such as that:
            char *cp = "Hello.";

          In this case, the value '*cp' which Pointer indicate, is 'H',
          so that Conditional Expression 'if(*cp == 'H')' is true.

*@subject ŸStruct and Pointer kp112l
          –Reference of Pointer 'mateP' which indicate 'struct SchoolMate'
          –Reference of Union is as same.

          [Example] Declaration
          sturct SchoolMate {
              int id;
              char name[10];
          }

          struct Schoolmate *mateP;

          [Example] Reference
          (*mateP).id  // The expression means to refer to the member of Struct which Pointer indicate.
                       // The Priority-bracket '()' cannot be omited, because of Operator priority.
                       // If it were omited such as '*mateP.id', the expression means '*(mateP.id)' as different meaning.
          
          mateP -> id  // Operator '->' is an abbreviation of above, 
                       // which is one Operator of two characters '-' and '>',
                       // so that two characters cannot be inserted white-space between both.

          mateP->xp->value  // When member of Struct which Pointer 'mateP' indicate, is another Pointer 'xp',
                            // the Operators '->' can be used combinedly.

*@subject ŸFunction and Pointer kp113l
          –Array of Function Argument
            => ŸArray and Pointer 
               –Array of Function Argumentkabovel

*@subject –Struct of Function Argument kp114l
          We can give Struct to Function Argument in C language,
          generally, we often give Pointer of Struct to there.

          [Example]
          int buffer[BUFFER_SIZE];
          FILE *fp;

          fgets(buffer, BUFFER_SIZE, fp);

          The Argument 'fp' is Pointer 'FILE*' of Struct 'struct FILE'.

          In general, Function about Graphics often has many Arguments,
          Because the more Argument is written by us often is the more mistakes which we are likely to,
          šwe should give a Struct which is packed many Variables as the Members of 'struct', to Argument one struct.

*@subject Ÿmulti Return-Value of Function by using Pointer kp114l
          Function can return only one value by using 'return' statement in C language.
          In that case, by using Pointer, Function can be return multi values actually.

          [Example]
          int x = 100;
          int y = 3;
          int divideP;
          int restP;

          calcDivide(x, y, &divideP, &restP);

          -------------------
          void calcDivide(int x, int y, int *divideP, int *restP) {
              *divideP = x / y;
              *restP = x % y;
          }

          By that, the origin of calling Function is actually returned two values, such as divideP = 33, restP = 1.
          The '&divideP, &restP' is called "Reference Giving" to Argument.

          Function is generally "Value Giving" to Argument in C language.
          In this case, Function cannot return two values by "Value Giving", such as below.
          When Control is returned from the Function, the local values of 'divid' and 'rest is disposed,
          though they are assigned in there.

             void calcDivide(int x, int y, int divide, int rest)  { ... }

          Therefore, "Reference Giving" to Argument by using Pointer, can return multi values.

*@subject ŸPointer of Function kp115l
          Pointer of Function: Pointer which indicate a Function can be defined.

          [Example] 
          int (*fp) (char);  

          It is Definition of Pointer 'fp' which indicate Function whose Argument is one 'char' Type and whose Return-Type is 'int' Type.
          It is annotation that the brackets '()' are different meanings.
          The former express priority bracket, and the later express Argument of Function.
          
          [Consideration Procedure of Definition or Declaration]
          1. We want to define Pointer 'fp'.
          2. It is Pointer which indicate Function. 
             Then we write with Indirect Operator '*', 
             so that it can be a Pointer which indicate Function '*fp'.

          3. The Priority of Indirect Operator '*' is inferior than bracket '()' as Argument of Function,
             so that we should write with Priority bracket '()'.
             It is a Function '(*fp)' still.

          4. Because it is a Function, it is written with bracket '()' of Argument, such as that:
               (*fp)(char c)

          5. Because it is a Function, we should write Return-Type before that.
               int (*fp)(char c)

          6. Because Definition is a statement, we should write with Termination ';'.
               int (*fp)(char c);

          7. Then Variable name of Argument be omited, so that it has just been completed.
               int (*fp)(char);

*@advance Command Table by using Pointer of Function kp116l
          [Example]
          typedef struct CommandTable {
              char *name;           // Command name
              void (*func)(void);   // Function which is called.
          } COMMAND;
          -----------
          COMMAND tableAry[] = {     // <- Initalizer of Array
              {"list", cmd_list },   // <- Initalizers of Struct
              {"help", cmd_help },   // each 'cmd_xxxx' are Function name.
              {"bomb", cmd_bomb },   // It is not necessary to write such as '&cmd_xxxx'.
              {"exit", cmd_exit },   // It express Pointer only by writing Function name.
          };

          int tableArySize = sizeof(tableAry) / sizeof(COMMAND);  
                                     // The Number of Array elements can be caluculated,
                                     // by dividing 'Memory Size of whole tableAry[] / Memory Size of COMMAND as one element of Array tableAry[0]'

          for (int i = 0; i < tableArySize; i++) {
              if (strcmp(str, table[i].name) == 0) {
                  (*table[i].func)();   // call Function
                  break;
              }
          }//for

*@advance Handler kp116, p282l
          Handler: The other example as Pointer of Function is Handler, which is called "Call Back Funtion".
                   It is a system of Event Handler, such as that:
                     While we registered self-defined Pointer of Function somewhere,
                     when an Event is happend, Event Handler will call the Pointer of Function.

          => more detail is to see Function 'signal' in Standard LibrarykCAnsiYH Chapter 12 | p282l

*@subject ŸPointer of Pointer kp117l kC99YH11_Pointer\MainPointerOfPointerSample.cl
          Pointer of Pointer: Pointer which indicate address of another Pointer.
            EBecause Pointer is one of Variables, of course, there is an address of itself,
              so that we can define Pointer of Pointer, which indicate address of another Pointer.
            EIt can be done recursively, such as 'Pointer of Pointer of Pointer of Pointer ... ',
              so that we can do by adding more '**** ... '.
              The word "recursive" means to operate the thing of same structure with oneself repeatedly.

          [Format]
          T  *tp;    // Defintion Pointer which indicate Variable of T Type.
          T  **tpp;  // Defintion Pointer of Ponter, which indicate Pointer which indicate Variable of T Type.

          tpp = &tp; // Assignment address of Pointer 'tp' to Pointer of Pointer 'tpp'.

*         [Example]
*         –Definition
*         int x;     define int type variable 'x'.
*         int *p;    define Pointer 'p' which storage the address of int type variable 'x'.
*         int **pp;  define Pointer 'pp' which storage the address of Pointer 'p' which storage the address of int type variable 'x'.
*
*         [Example]
*         –Assignment
*         x = 100;   // It assign value '100' to 'x'.
*         p = &x;    // It assign address of 'x' to 'p'.
*         pp = &p;   // It assign address of 'p' to 'pp'.
* 
*         [Example] 
*         –Reference
*         printf("x:    %d \n", x);    // It show value of variable 'x'.
*         printf("p:    %p \n", p);    // It show address of variable which Pointer 'p' is storaging.
*         printf("*p:   %d \n", *p);   // It show value of variable which Pointer 'p' indicate.
*         printf("pp:   %p \n", pp);   // It show address of Pointer which Pointer of Pointer 'pp' is storaging.
*         printf("*pp:  %p \n", *pp);  // It show address of variable which Pointer 'p' is storaging, which Pointer of Pointer 'pp' is storaging.
*         printf("**pp: %d \n", **pp); // It show value of variable which Pointer 'p' indicate, which Pointer of Pointer 'pp' is storaging.
* 
*         => copy from kC99YH11_Pointer\MainPointerOfPointerSample.cl
* 

*@subject Ÿ<stdlib.h> -- strtol() kp117, p329l
            A Function which convert String text to numeric value.

            [Format]
            long  strtol(const char *s, char **endpp, int base)

            --------
            It convert String text '*s' to 'long' Type numeric value, and return the value.

            The second Argument is Pointer of Pointer '**endpp',
            which '*endpp' is the location of String at the time that the conversion has just finished,
            and '**endpp' can be returned too, because of "Reference Giving" by Pointer.
            If '**endpp' is NULL, '*endpp' is assigned nothing.

            The third Argument 'int base' express the base of how-decimal.

            [Example] kCAnsiYH p118l
            char *endptr;
            long li;
            char valueString[] = "12345,67890";

            li = strtol(valueString, &endptr, 10)
            -------

            When it finished, Valiable 'li' is assigned '12345' as 'long' Type,
            and Pointer 'endptr' is assigned the location ',' in String.

            Consequently, when we want to assign Pointer address,
            we need give Pointer of Pointer to Argument of Function.

*@subject ŸGeneric Pointer 'void*': kp118l


[EOF] 