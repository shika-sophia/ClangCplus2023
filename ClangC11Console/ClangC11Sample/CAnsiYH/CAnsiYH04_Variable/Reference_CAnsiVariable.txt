/**
*@directory ClangC11Console / ClanC11Sample / CAnsiYH / CAnsiYH04_Variable
*@fileName  Reference_CAnsiVariable.txt
*@reference C99YH    åãèÈ ç_ ÅwCåæåÍÉvÉçÉOÉâÉ~ÉìÉOÉåÉbÉXÉì [ì¸ñÂï“] ëÊÇRî≈ÅxSB Creative, 2019
*@reference CAnsiYH  åãèÈ ç_ ÅwCåæåÍÉvÉçÉOÉâÉ~ÉìÉOÉåÉbÉXÉì [ï∂ñ@ï“] êVî≈Åx  SB Creative, 2006
*@reference C11DS    arton  Åwì∆èK C êVî≈Åx„ƒâjé–, 2018
*
*@content CAnsiYH Chapter 4  Variable / p73-
*@summary Reference_CAnsiVariable.txt
          Å° Variable ÅkCAnsiYH p73Ål
            [Difference of Variable and Object]
          ÅüLeft Side Value ÅkCAnsiYH p74Ål
           ÅEVariable
           ÅEPointer
           ÅEArray
           ÅEStruct member
           ÅEPointer indirect reference for Struct
          ÅüAttribute of Variable ÅkCAnsiYH p74Ål
           ÅñType       => ÅkCAnsiYH03_Type\Reference_CAnsiType.txtÅl
           ÅñStorage Class  (= Storage Duration)
             ÅEtypedef  => ÅkCAnsiYH p52 | CAnsiYH03_Type\Reference_CAnsiType.txtÅl
             ÅEauto
             ÅEstatic
             ÅEextern
             ÅEregister
          ÅüPredefined Keyword 'auto'   ÅkCAnsiYH p75, p82Ål
          ÅüStack Overflow ÅkCAnsiYH p76Ål
         ÅyAnnotationÅz'goto' statement  ÅkCAsinYH p78Ål
          ÅüPredefined Keyword 'static' ÅkCAnsiYH p77-78, p81Ål
           ÅñInternal Linkage    ÅkCAnsiYH p77-78ÅlÅkCAnsiYH02_Basic\Reference_CAnsiBasic.txtÅl
           Åñstatic Storage ClassÅkCAnsiYH p81Ål
          ÅöConceal Function    ÅkCAnsiYH p79Ål
          ÅüPredefined Keyword 'extern'   ÅkCAnsiYH p80, p123Ål
          ÅüPredefined Keyword 'register' ÅkCAnsiYH p81Ål
          ÅüDifferences of Declaration and Definition ÅkCAnsiYH p82Ål

*@English [E] assign      (v):     äÑÇËìñÇƒÇÈÅAë„ì¸Ç∑ÇÈ  | assignment (n)
          [E] classification (n):  ï™óﬁ, ãÊï™, ÉNÉâÉXï™ÇØ, éØï , óﬁå^âª | classify (v)  =:= category (n) | categorize (v)
          [E] restrict    (v):     êßå¿Ç∑ÇÈ, å¿íËÇ∑ÇÈ, ãKêßÇ∑ÇÈ | restriction (n) | restrictive (adj)
          [E] manners     (n):     É}ÉiÅ[, çÏñ@, çsãV, ïóèK, ïóë≠, çsãV çÏñ@  =:= etiquette (n) ÉGÉ`ÉPÉbÉg, É}ÉiÅ[, ãVóÁ, óÁãV çÏñ@, óÁãV, çÏñ@
          [E] dispose     (v):     èàï™, îjä¸, îpä¸, éÃÇƒÇÈ  | disposal (n)
          [E] sequential (adj):    èáéü, èáî‘, èá, íÄéü, éüÅX
          [E] efficient  (adj):    å¯ó¶ìI  efficiency (n) å¯ó¶ | effective (adj) óLå¯Ç» 
          [E] intuitive  (adj):    íºä¥ìI, íºäœìI, ÇÌÇ©ÇËÇ‚Ç∑Ç¢ | intuition (n)   íºä¥, íºäœ, ä®

          ÅñProgramming
          [P] definition  (n):     íËã`
          [P] declaration (n):     êÈåæ, ÉvÉçÉgÉ^ÉCÉvêÈåæ
          [P] operator    (n):     ââéZéq
          [P] operand     (n):     îÌââéZêî (= ââéZéqÇ…ÇÊÇËåvéZÇ≥ÇÍÇÈêîíl)  | opeland (n)
          [P] qualifier   (n):     èCè¸éq
          [P] identifier  (n):     éØï éqÅAñºëO
          [P] storage class:       ãLâØÉNÉâÉX
          [P] predefined keyword:  éwíËéq
          [P] Object-Oriented:     ÉIÉuÉWÉFÉNÉgéwå¸
          [P] Control   (n/v):     êßå‰ (= ÇªÇÃéûì_Ç≈ÅAÉvÉçÉOÉâÉÄÇ™èàóùÇµÇƒÇ¢ÇÈçsÇ‚èÍèä)
          [P] concealment (n):     âBï¡ (= userÇ…ïKóvÇ»èÓïÒà»äOÅAå©ÇπÇ»Ç¢ÇÊÇ§Ç…Ç∑ÇÈÇ±Ç∆) | conceal (v)

*@see 
*@author  shika
*@date    2023-01-29
*/ 

*@subject Å° Variable ÅkCAnsiYH p73Ål
          Variable: The named space in Memory, whose name is called "Variable-name". 
          Object:   The origin sense is thing or target in English.
                    There is to be called 'Object', instead of 'Variable'.

          [Difference of Variable and Object]
          They are not always the same thing.
          If it is a named thing in Memory, it can be called "Variable".
          Whichever named or not named in Memory, it can be called "Object in Memory", as general saying as a space in Memory.
          such as Object which Pointer indicate:
          the Object is including named 'Variable' or un-named a space in Memory.

          By the way, we call the file which Compile yield, "Object File".
          The 'Object' means a target, or is regarded a file as a thing.

*@subject ÅüLeft Side Value ÅkCAnsiYH p74Ål
          Left Side Value or Expession: 
            The Expessions as target of assinment.
            In other word, the Opeland which is assigned by Assign Operator.
            The symbol '=' only means 'assignment' in Program language, not means 'equal' in Mathematics.

            So that we need distinguish Left or Right side of Assign Operetor '=', as like that:
            Left  side is Variable as target of assignment, 
            Right side is value    as origin of assignment.

          [Kinds of Left Side Value or Expression]
          ÅEVariable
          ÅEPointer
          ÅEArray
          ÅEStruct member
          ÅEPointer indirect reference for Struct

          [Example]
          int x = 1 + 2;   // Variable
          int *p = &i;     // Pointer
          a[i] = 100;      // Array
          mate.id = 1;     // Struct member
          mateP->id = 2;   // Pointer Indirect Reference for Struct

*@subject ÅüAttribute of Variable ÅkCAnsiYH p74Ål
          Attribute of Variable: The two specifications which Variable have, such as Type, Storage Class.
          ÅñType: The data type which Variable can storage. 
                  => see ÅkCAnsiYH03_Type\Reference_CAnsiType.txtÅl

          ÅñStorage Class: = Storage Duration:
              The Predefined Keywords as a Qualifier which express the life length of Variable.

            Class: It means "Classification of Storage Area in Memory", in C language.
                   In this case, it does not mean "Class of Object-Oriented" in C++.

          [Kings of Storage Class Predefined Keywords]
          ÅEtypedef  => ÅkCAnsiYH p52 | CAnsiYH03_Type\Reference_CAnsiType.txtÅl
          ÅEauto
          ÅEstatic
          ÅEextern
          ÅEregister

*@subject ÅüPredefined Keyword 'auto'ÅkCAnsiYH p75Ål
          Control: The row or place which a Program is operated in that time.
                   Program is a text file which is described the order of operations.
                   
          auto Storage Class: 
         ÅEThe life length of Identifier that:
           An Identifier is defined in a Block, remained through while it is in the Block,
           and automatically disposed when Control go out of the Block.

         ÅEIt can be used only at the time of Definition in a Brock.

         ÅEQualifier 'auto' is omitable and usually used with being omitted,
           in this case, a definition is automatically recognized as 'auto' Storage Class by Compiler.
           of course, it can be explicitly qualified with 'auto'.

           But it seems that we have almost never seen in source code of C, 
           because it usually used with being omitted.

         ÅEVariable with 'auto' Storage Class, is not initialized implicitly, 
           in this case, the value is state of "not determined",
           so that we should explicitly initialize it, as a Programming manner.
          (On the other, Variable with 'static' Storage Class, 
           is implicitly initalized as the value is 0, as next subsection,
           nevertheless, we should explicitly initialize it, as a Programming manner.)
               
         ÅEVariable with 'auto' Storage Class, is disposed from Memory, 
           when Control go out of the Block, as [Å~][Example] below.

          [Example] in a Block
          {
              int x;   // or 'auto int x;'
          }

          [the Attributes of the 'x']
          ÅEIdentifier:    x
          ÅEType:          int
          ÅEValue:         (not determined)
          ÅEScope:         Block Scope
          ÅELinkage:       Internal Linkage
          ÅEStorage Class: auto

          [Å~][Example] Pointer is a Block
          {
             int *p;
             {
                int x;
                p = &x;
             }
             func(p);
          }

          In the above case:
          Though Pointer 'p' is defined out of the inner Block,
          Variable 'int x' is defined and 'p' is assigned address of 'x' in the inner Block.

          When Control go out of the inner Block, 'x' is disposed from Memory.
          Pointer 'p' of Function 'func(p)' is referred nothing (= the state is called "NULL"), in that time.
          
          Consequently, Variable with 'auto' Storage Class, is disposed from Memory, 
          when Control go out of the Block.

          [ÅZ][Example] Pointer is a Block
          {
             int x = 100;       
                          // or 'int *p = &x;'
             func(&x);    // or 'func(p);'
          }

*@subject ÅüStack Overflow ÅkCAnsiYH p76Ål
          ÅEVariables with 'auto' Storage Class, is storaged in Stack Area in Memory.
            Stack Area is usually more effeciant with reading and writing of Memory than Heap Area of 'static' Storage Class.
           
            => see [Memory Model in Java] ÅkCAnsiYH03_Type\Reference_CAnsiTypeChange.txtÅl

          Stack Overflow:
          If the Stack Area is too small to storage large amount of 'auto' Variables,Å@(the storage space depends on Compiler),
          Compiler will throw Compile Error of "Stack Overflow", because Stack Area will be shotage of Memory space.

*@subjectÅyAnnotationÅz'goto' statement ÅkCAsinYH p78Ål
          Variable which is explicitly initialized in a Block, is certainly done,
          when Control normally enter into the Block, such as sequencially operation or Calling Function.
          But it is not always done,
          when Control jump into the Block by using 'goto' statement.

*@subject ÅüPredefined Keyword 'static' ÅkCAnsiYH p77-78, p81Ål
          static: The original sense in English is fixed, immutable, quiet, silent, gently; <-> as the opposite sense, 'dynamic'.
            There are two senses in C language, as next.
            (1) Variable or Function which is qualified 'static' at out of a Block, have Internal Linkage.
            (2) Variable which is qualified 'static' in a Block, have static Storage Class, adding above.

          ÅñInternal LinkageÅkCAnsiYH p77-78, p81Ål=> see ÅüLinkageÅkCAnsiYH02_Basic\Reference_CAnsiBasic.txtÅl
          An Identifier with 'static' always have Internal Linkage, of course in a Block, even if out of a Block, 
          so that the Identifier cannot be seen from any other files.

          An Identifier of Function with 'static' always have Internal Linkage,
          The Function can be seen and referred from this file only.

          [Example] at out of a Block:
          static int x;  // x which has Internal Linkage, cannot be seen from any other files.
          int y;         // y which is not restricted anything, can be seen and referred from any files.

          Åñstatic Storage ClassÅkCAnsiYH p81Ål
          static Storage Class: 
            ÅEBefore starting a Program, Identifier is initialized as the value is 0, one time of first only.
              While the Program is running, the Identifier is remained throughout. 
          
          [Example] at out of a Block
          int a;

          [the Attributes of the 'a']
          ÅEIdentifier:    a
          ÅEType:          int
          ÅEValue:         0
          ÅEScope:         File Scope
          ÅELinkage:       External Linkage
          ÅEStorage Class: static

          [Example] in a Block
          {
             static int a;
             ...
          }

          [the Attributes of the 'a']
          ÅEIdentifier:    a
          ÅEType:          int
          ÅEValue:         0
          ÅEScope:         Block Scope
          ÅELinkage:       Internal Linkage
          ÅEStorage Class: static

          In the case of being defined 'in a Block', 
          Storage space of the Identifier is ramained still, even if out of the Block
          but the Identifier cannot be seen out of the Block, because its Scope is Block Scope.

          An Identifier which has static Storage Class, is initialized as the value is 0, one time of first only.
          ÅöAs Programming manners, we should explicitly intialize any Variables,
          though some of them is automatically (= implicitly) initialized, we should not expect that.

*@subject ÅöConceal Function ÅkCAnsiYH p79Ål
          Concealment: Programmer should describe a source code with hidding the inner informations as possible, excepting necessary.
                       It is called "Concealment".

          Conceal Function: A Function with 'static' Storage Class, cannot be seen and called from any other files,
                            so effective that we can conceal the Function.
          
*@subject ÅüPredefined Keyword 'extern' ÅkCAnsiYH p80Ål
          extern: The prefifined keyword of Storage Class which means External Linkage.
                  It is the abbreviation of "external".
                  It can be used with adding Variable and Function, at the time of Declaration.
                  It express that the Identifier is defined any other files or anywhere place.

          ÅEVariable and Function with 'extern' Storage Class, can be seen and referred from any other files.

          => 'extern' in case of being likely to mistake, see ÅkArray and Pointer / CAnsiYH Chapter 6 | p123Ål

          [Example] Declaration
          extern int global_id;
          extren char global_buffer[];  // It is not set the size of Array, yet.
                                        // it is set at the time of Definition.

          [Example] Definition in somewhere other file.
          int global_id;
          char global_buffer[100];

*@subject ÅüPredefined Keyword 'register' ÅkCAnsiYH p81Ål
          ÅEregister: ÅEThe Predefined Keyword which means frequently to be accessed.
                      ÅEIt is used with Variable or Argument.
                      ÅEIt tell Programmer for Compiler to be going to use frequently,
                        Compiler try to assgn space of Memory to it efficiently.
                      ÅEActually, Compiler will try to storage it to Register of CPU, not to Memory.
                        It is not always determined how faster is Variable or Argument with 'register' operated, 
                        because Register of CPU is limited available space.

          [Example]
          register int i;

          for (i = 0; i < DATA_MAX; i++) {
             ...
          }

*@subject ÅüDifferences of Declaration and Definition ÅkCAnsiYH p82Ål
          (According to the Text BookÅkCAnsiYHÅl, 
           this sub-section is not strictly grammatical explanation.
           this is author's intuitive imagination.)
          Declaration: It is infomation only.
                       [Function] It is expressed Function as Return-Type, Argument-Type, and Identifier.
                       [Array]    It need not be determined the size of Array.
                       [Memory]   Any space of Memory is not ocuppied, yet.
                       [Times]    It can be done however many times, excepting conflict each other.

          Definition:  It is adding actual contents to above, too.
                       [Function] It is expressed Function as adding actual operation to above, too.
                       [Array]    It need be actually determined the size of Array.
                       [Memory]   A space of Memory is taken a place, at the time of Definition.
                       [Times]    It can be done only one time in a Block.
                       Definition is including Declaration.
                       Therefore to define become to declarate, though the opposite is not true.

[EOF]