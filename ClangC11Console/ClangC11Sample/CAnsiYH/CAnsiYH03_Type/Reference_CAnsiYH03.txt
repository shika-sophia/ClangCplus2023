/**
*@directory ClangC11Console / ClanC11Sample / CAnsiYH / CAnsiYH03_Type
*@fileName  Reference_CAnsiYH03.txt
*@reference C99YH    結城 浩 『C言語プログラミングレッスン [入門編] 第３版』SB Creative, 2019
*@reference CAnsiYH  結城 浩 『C言語プログラミングレッスン [文法編] 新版』  SB Creative, 2006
*@reference C11DS    arton  『独習 C 新版』翔泳社, 2018
*
*@content CAnsiYH Chapter 3  Type / p39-
*@summary Reference_CAnsiYH03.txt

*@English [E] primitive (adj):    原始的、基本的
          [E] derive    (v):      派生する、導く、由来する
          [E] specification (n):  仕様、規格
          [E] implicitly (adv):   暗黙的  <->  explicitly  明示的
          [E] classify   (v):     分類する、区分する、気密に分類する
          [E] moderate  (adj):    適当, やや, 緩やか, 中程度, 程よく
          [E] strict    (adj):    厳密, 厳しく, 固く, 厳格, 厳重, あくまで
          [E] opportunity (n):    機会
          [E] omit       (n/v):   抜かす、省く
          [E] abbreviate (v):     省略する、短縮する  abbreviation (n) 省略形
          [E] enumerate  (v):     数える、列挙する    enumeration  (n) 列挙
          [E] correspond (v):     相当する、一致する、対応する
          [E] sequence   (n):     一連、連続、数列、文字列、列、順序
          [E] orthodox   (n):     正統、正統派
          [E] conclusion (n):     結論  =:= consequence (n) 結果
          [E] grammar / grammour  (n) 文法   grammatical (adj)
          [E] intention  (n):     意図　　intend (v) | contemplate (v) 意図する、企図する、熟視する
          [E] appropriate (adj):  適した、適切

          ＊Programming
          [P] define    (v):      定義する
          [P] declarate (v):      宣言する
          [P] transplantable (adj):  移植性がある  =:= portable  運びやすい
          [P] operator  (n):      演算子
          [P] qualifier (n):      修飾子
          [P] identifier(n):      識別子、名前
          [P] initializer(n):     初期化子 { }
          [P] enumerator (n):     列挙子
          [P] iterate   (v):      繰り返し処理する
          [P] alias     (n):      別名、エイリアス

          ＊Mathematics
          [M] precision (n):      精度、桁数   = digit (n)
          [M] recursive (adj):    再帰的 (= 自分自身と同じ構造のものを繰り返すこと) | recursion (n), recurse (v)
          [M] dimension (n):      次元
          [M] numeric (n/adj):    数値、数字の
          [M] set / subset (n):   集合 / 部分集合

*@see     ReferenceDocument\Reference_NumericTypeRange.txt
*@author  shika
*@date    2023-01-20
*/ 

*@subject ■ Type  〔p39〕
          Type: ・Data kinds of Variable value
                ・Compiler decide how to operate the value by Type.
                ・When calculate different Types, Compiler do Type-Change implicitly (= automatically) in necessary.
                ・How Bytes or Bits each Types have in Memory, depend on Comiler,
                  They are moderately specified by C. more strictly by C++.

          [Kinds of Types]
          ・Primitive Type: Types default-defined by specification of C language; such as char, int, float, double, and void.
          ・Derived Type:   Types self-defined by programmer; such as Array, Function, Pointer, Struct, Union.

*@subject <limits.h> 〔CAnsi p39, p272〕〔C99YH 10 | p49, p206〕
          ・This is a Standard Header File default-defined by specification of C language.
          ・It define the maximum and minimum constant value of Primitive Types.
          ・Because they depend on Compiler, they are sometimes different.
          ★By using these constant values defined in it, a program is to be more transplantable.

          【Notation】in this Compiler case:  (Compiler is clang-C11 of Visual Studio 2019)
           It is no difference between 'int' and 'long'. (= the same range)

          => see another Headers and more detail.〔ReferenceDocument\Reference_NumericTypeRange.txt〕

*@subject ◆Type name
          The opportunity of using Type name:
          ・When you declarate a Global Varianle.
          ・When you define a Local Variable.
          ・When you expilcitly change Type by using Operator Cast expressed as '(Type)'.
          ・When you use Operator 'sizeof(Type)', as its Argument.

*@subject ◆Primitive Types: default-defined by specification of C language
          ・Whole of Types in C is based on this and yielded from this.

          ＊char:   Character
          ＊int:    Integer
          ＊float:  Single-Precision Floating-Point Number
          ＊double: Double-Precision Floating-Point Number
          ＊void:   Type expressing empty.

*@subject ◆Derived Types: self-defined by programmer
          ＊Array
          ＊Function
          ＊Pointer
          ＊Struct
          ＊Union
          
*@advance ◎Recursive Definition 〔p41〕
          [Math] recursion (n):  To iterate as same structure as itself.
                                 -> recurse (v), recursive (adj)

          Derived Types is available recursively.
          It is able to create many numbers of new Types, by recursively defining of Deriverd Type.

          [Example]
          T-Type:                    Asumming there were T-Type, T-Type is a new Type.
          Array of T-Type:           If you define as a array 'T[]', it is created as a new Type more.
          Array of Array of T-Type:  As same, this is created as a new Type too, it is called "2-Dimension Array" T[][].
            :
          (countless)

*@subject ◆Integer Types 〔p41〕
          ・The specification of Compiler adjust each Types range to easily use for the device.
          ・Depending on Compiler, short or long sometimes don't have the range as below.

          [Kinds of Integer Types]
          ＊char:              8 bit = 2 ^  8 = 256
          ＊short [int]:      16 bit = 2 ^ 16 = 65536
          ＊int:              32 bit = 2 ^ 32 = 4294967296
          ＊long [int]:   
          ＊long long [int]:  64 bit = 2 ^ 64 = 18446744073709551617
          ※ [int] can be omited.

          + signed:    The keyword is used by adding before Type above,
                       to tell Compiler that the Type have signs, such as '+' or '-'.
                       It is omittable, in that case (= no keyword), it means 'signed'.
          + unsigned:  The keyword is used by adding before Type above,
                       to tell Compiler that the Type have no signs, and plus value only.

          => see Range of Integer Types〔ReferenceDocument\Reference_NumericTypeRange.txt〕

*@subject ◆Character Types 'char' 〔p42〕
          ・'char' storages one character code value as numeric value, expressed with single quote [ ' ' ].
          ・char '0' is different from int 0. / '0' value is 48 as if ASCII.
          ・char 'a' is different from "a". / 'a' is char constant value. / "a" is String text.
          
          ・String text is defined as Array of 'char' Type. 
            While [Java][C#] have String Type, but [C][C++] don't have it.
          ・'char' Type is a sort of Integer Types, because the value is storaged as numeric value in Memory.
            Therefore 'char' can be calculated as like Integer.
          ・'char' can be added keywords 'signed' or 'unsigned' before Type.
          
          ・In case of input excepting chatacter, which the value is minus or not, depend on Compiler.
          ・In case of wide-character, as same.
          ・In case of comparing values high or low, it is important difference with 'signed' or 'unsigned'.
          ★Programmer should describe 'signed' or 'unsigned' explicitly.
          
*@advance ◎well-known Failure
          ・In case of using Function 'getchar()', The value should be storaged in 'int' Type, not 'char';
            because conatant value of 'EOF' which express end of file, is defined as -1,
            it is important to ensurely operate 'EOF' gotton by 'getchar()'.
          ・That is well-known Failure for programmer.
     
          [Example]
          int c;   // <- Here, not 'char'.

          while ((c == getchar()) != EOF) {
              putchar(c);
          }

*@subject ◆String text 〔p44〕
          ・String text is defined as Array of 'char' Type. 
            While [Java][C#] have String Type, but [C][C++] don't have it.
          ・It is expressed with double quote [ " " ].

          [Example]
          ＊These are the same meaning.
          char  strAry[] = "ABC";                 // In this case, '\0' NULL Character is automatically inserted by Compiler.
          char  strAry[] = {'A', 'B', 'C', '\0'}; // using Initializer '{ }' 

          ＊These are the same behavior, which shows "ABC".
          printf("%s\n", "ABC");
          printf("%s\n", strAry);
          printf("%s\n", &strAry[0]);    // [ & ] is Address Operetor of Pointer〔below〕

*@subject ◆Enum Type 〔p45〕
          enum: The keyword of 'enum' Type, which enumerate constant Identifer (= called "Enumerator"), 
                corresponding with the int value, and delimitted by [ , ].
                It is used at declaration of 'enum' Type.
                (In Pascal which is a prorgram language, the Partial Range Type is similar with this, because it is self-defined as a subset of Integer Types.
                 But it of Pascal is defined with setting of ranges between maximum and minimum, it is different from 'enum' of C)

          [Format] Declaration
          enum tag_name { enumerator1, enumerator2, enumerator3 ... };

          typedef enum tag_name  { 
              enumerator1, enumerator2, enumerator3, ... 
          } alias;

          ・tag_name:  It is Identifier of 'enum' name, and it is omitable.

          ・enumerator1, enumerator2 ... :
              The Enumerator name need be unique, and need be diffenent from any Identifiers in the same scope.
              The sequece of Enumerator or 'enumerator = constant expression', is delimitted by [ , ].
              By declaration, each Enumerator automatially have int value, such as 0, 1, 2 ... .
              Or these enum 'int' values can be self-defined by describing 'enumerator = constant expression'. => see〔＊self-assign the value〕

          ・alias:  Operator 'typedef' can define alias name to Type.

          [Format] Definition and Assignment of enum value 
          enum tag_name Variable_name = enum_value;

          [Example]
          -- Declaration and Definition --
          enum EnumColorRGB {
              RED, GREEN, BLUE
          };

          enum EnumColorRGB colorR = RED; 
          enum EnumColorRGB colorG = GREEN; 
          enum EnumColorRGB colorB = BLUE;
          
          -- Declaration and Definition at the same time --
          enum EnumColorRGB { RED, GREEN, BLUE } colorR = RED;

          -- Declaration and Definition using 'typedef' --
          typedef enum EnumColorRGB {
              RED, GREEN, BLUE
          } Color;

          Color colorR = RED;

*@subject ＊'#define' instead of 'enum' definition
          #define: One of Directive for Pre-processor, expressed by '#'.
                   It define constant Identifier with the constant value.
                   =>〔CAnsiYH01_Introduction\Reference_CAnsiYH01.txt〕

          ・To use '#define' instead of 'enum' definiition:
            It is almost similar as orthodox 'enum' definition, but see below.

          [Example]
          #define RED 0
          #define GREEN 1
          #define BLUE 2
          ----
          int colorR = RED;

         ・The "almost" means that: 
         Using '#define', it define the Token as Identifier only.
         Pre-processor operation will replace the Token to calling a Function which return the constant value.
         Before Compiler will parse and grammatically validate by C language, the replacement will have been done;
         so that Compiler cannot find out grammatical errors in the source code, and
         so that Symbolic-Debuger cannot refer the Symbol name.
   
         ★[Conclusion] 
         Programmers had better use orthodox 'enum' definition than '#define' way.

*@subject ＊'const' instead of 'enum' definition
          const: The keyword which define consatant Identifier with the constant value,
                 and after definition, It prevent to be assigned some values by user. 

         ・It is almost similar as orthodox 'enum' definition.
           But not using 'enum' definition, it is weaken with Programmer's intention that
           these Identifiers are concerned each other, one value of the same symbol.

         [Example]
         const int RED = 0;
         const int GREEN = 1;
         const int BLUE = 2;

*@subject ＊self-assign the int values 
          ・The enum 'int' values can be self-defined by describing 'enumerator = constant expression'.
          ・They are omitable, in this case, automatically assigned such as [ 0, 1, 2, ... ].
          ・They can be assigned the same value with different Enumerators, 
            so that you can express that different Enumerators do the same behavior, as Alias,
            but so that it maybe not appropriate with 'enum' intention.

          [Format]
          enum tag_name { 
              enumerator1 = constant_expression1,
              enumerator2 = constant_expression2,
              enumerator3 = constant_expression3,
                :
          };

          [Example]
          enum ErrorCode {
              MEMBER_ERROE = 10,
              CALC_ERROR = 11,
              UNKOWN = 12,
          };

          ・If the values are incremental by +1, you can describe the first value only, as same meaning.
          [Example]
          enum ErrorCode {
              MEMBER_ERROE = 10,
              CALC_ERROR,
              UNKOWN,
          };

*@subject ◆Floating-Point Number Types〔p47〕

(Editing...)

[EOF]